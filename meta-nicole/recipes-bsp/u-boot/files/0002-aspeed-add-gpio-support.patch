From a8bedffa06e66f798189dae661ceceab95222b7d Mon Sep 17 00:00:00 2001
From: Alexander Filippov <a.filippov@yadro.com>
Date: Tue, 19 May 2020 18:55:41 +0300
Subject: [PATCH] aspeed: add gpio support

This is an initial support for the parallel GPIO pins directly connected
to the AHB on the Aspeed 2400/2500.

This brings the functions and a shell command to manipulate the GPIO
state. The GPIO value reading and writing work in non interrupt mode
only.

Signed-off-by: Alexander Filippov <a.filippov@yadro.com>
---
 .../arm/include/asm/arch-aspeed/aspeed-gpio.h |  67 +++
 arch/arm/mach-aspeed/Makefile                 |   1 +
 arch/arm/mach-aspeed/ast-gpio.c               | 568 ++++++++++++++++++
 3 files changed, 636 insertions(+)
 create mode 100644 arch/arm/include/asm/arch-aspeed/aspeed-gpio.h
 create mode 100644 arch/arm/mach-aspeed/ast-gpio.c

diff --git a/arch/arm/include/asm/arch-aspeed/aspeed-gpio.h b/arch/arm/include/asm/arch-aspeed/aspeed-gpio.h
new file mode 100644
index 0000000000..a401ec0320
--- /dev/null
+++ b/arch/arm/include/asm/arch-aspeed/aspeed-gpio.h
@@ -0,0 +1,67 @@
+/*
+ * SPDX-License-Identifier: Apache-2.0
+ * Copyright (C) 2020 YADRO.
+ */
+#ifndef _ASPEED_GPIO_H
+#define _ASPEED_GPIO_H
+
+#define ASPEED_GPIO_PORT_A 0
+#define ASPEED_GPIO_PORT_B 1
+#define ASPEED_GPIO_PORT_C 2
+#define ASPEED_GPIO_PORT_D 3
+#define ASPEED_GPIO_PORT_E 4
+#define ASPEED_GPIO_PORT_F 5
+#define ASPEED_GPIO_PORT_G 6
+#define ASPEED_GPIO_PORT_H 7
+#define ASPEED_GPIO_PORT_I 8
+#define ASPEED_GPIO_PORT_J 9
+#define ASPEED_GPIO_PORT_K 10
+#define ASPEED_GPIO_PORT_L 11
+#define ASPEED_GPIO_PORT_M 12
+#define ASPEED_GPIO_PORT_N 13
+#define ASPEED_GPIO_PORT_O 14
+#define ASPEED_GPIO_PORT_P 15
+#define ASPEED_GPIO_PORT_Q 16
+#define ASPEED_GPIO_PORT_R 17
+#define ASPEED_GPIO_PORT_S 18
+#define ASPEED_GPIO_PORT_T 19
+#define ASPEED_GPIO_PORT_U 20
+#define ASPEED_GPIO_PORT_V 21
+#define ASPEED_GPIO_PORT_W 22
+#define ASPEED_GPIO_PORT_X 23
+#define ASPEED_GPIO_PORT_Y 24
+#define ASPEED_GPIO_PORT_Z 25
+#define ASPEED_GPIO_PORT_AA 26
+#define ASPEED_GPIO_PORT_AB 27
+#define ASPEED_GPIO_PORT_AC 28
+
+#define ASPEED_GPIO(port, pin) ((ASPEED_GPIO_PORT_##port << 3) | (pin & 0x7))
+
+/* Direction values */
+#define ASPEED_GPIO_INPUT 0
+#define ASPEED_GPIO_OUTPUT 1
+
+/* Trigger values */
+#define ASPEED_GPIO_FALLING_EDGE 0
+#define ASPEED_GPIO_RISING_EDGE 1
+#define ASPEED_GPIO_LOW_LEVEL 2
+#define ASPEED_GPIO_HIGH_LEVEL 3
+#define ASPEED_GPIO_DUAL_EDGE 4
+
+/* Debounce values */
+#define ASPEED_GPIO_DEBOUNCE_NONE 0
+#define ASPEED_GPIO_DEBOUNCE_1 1
+#define ASPEED_GPIO_DEBOUNCE_2 2
+#define ASPEED_GPIO_DEBOUNCE_3 3
+
+extern int aspeed_gpio_get_value(unsigned gpio);
+extern int aspeed_gpio_set_value(unsigned gpio, unsigned value);
+extern int aspeed_gpio_get_direction(unsigned gpio);
+extern int aspeed_gpio_set_direction(unsigned gpio, unsigned direction);
+extern int aspeed_gpio_enable_interrupt(unsigned gpio);
+extern int aspeed_gpio_disable_interrupt(unsigned gpio);
+extern int aspeed_gpio_set_trigger(unsigned gpio, unsigned trigger);
+extern int aspeed_gpio_clear_interrupt(unsigned gpio);
+extern int aspeed_gpio_set_debounce(unsigned gpio, unsigned debounce);
+
+#endif /* #ifndef _ASPEED_GPIO_H */
diff --git a/arch/arm/mach-aspeed/Makefile b/arch/arm/mach-aspeed/Makefile
index 4af2a7c96a..1d09a25474 100644
--- a/arch/arm/mach-aspeed/Makefile
+++ b/arch/arm/mach-aspeed/Makefile
@@ -12,6 +12,7 @@
 
 
 obj-y += timer.o reset.o cpuinfo.o ast-scu.o ast-ahbc.o ast-sdmc.o
+obj-y += ast-gpio.o
 obj-$(CONFIG_AST_SPI_NOR) += flash.o
 obj-$(CONFIG_ARCH_AST2500) += platform_g5.o
 obj-$(CONFIG_ARCH_AST2400) += platform_g4.o
diff --git a/arch/arm/mach-aspeed/ast-gpio.c b/arch/arm/mach-aspeed/ast-gpio.c
new file mode 100644
index 0000000000..90910cacfa
--- /dev/null
+++ b/arch/arm/mach-aspeed/ast-gpio.c
@@ -0,0 +1,568 @@
+/*
+ * SPDX-License-Identifier: Apache-2.0
+ * Copyright (C) 2020 YADRO.
+ */
+
+#include <common.h>
+
+#include <asm/arch/aspeed-gpio.h>
+#include <asm/arch/platform.h>
+#include <asm/io.h>
+#include <linux/ctype.h>
+
+typedef struct _ast_gpio_regs
+{
+    uint32_t base;     /* data and direction registers */
+    uint32_t intcfg;   /* interrupt config */
+    uint32_t debounce; /* debounce config */
+    uint32_t cmdsrc;   /* command source config */
+    uint32_t data;     /* data read register */
+} ast_gpio_regs_t;
+
+static ast_gpio_regs_t ast_gpio_regs[] = {
+    /* A/B/C/D */
+    {AST_GPIO_BASE + 0x0000, AST_GPIO_BASE + 0x0008, AST_GPIO_BASE + 0x0040,
+     AST_GPIO_BASE + 0x0060, AST_GPIO_BASE + 0x00C0},
+    /* E/F/G/H */
+    {AST_GPIO_BASE + 0x0020, AST_GPIO_BASE + 0x0028, AST_GPIO_BASE + 0x0048,
+     AST_GPIO_BASE + 0x0068, AST_GPIO_BASE + 0x00C4},
+    /* I/J/K/L */
+    {AST_GPIO_BASE + 0x0070, AST_GPIO_BASE + 0x0098, AST_GPIO_BASE + 0x00B0,
+     AST_GPIO_BASE + 0x0090, AST_GPIO_BASE + 0x00C8},
+    /* M/N/O/P */
+    {AST_GPIO_BASE + 0x0078, AST_GPIO_BASE + 0x00E8, AST_GPIO_BASE + 0x0100,
+     AST_GPIO_BASE + 0x00E0, AST_GPIO_BASE + 0x00CC},
+    /* Q/R/S/T */
+    {AST_GPIO_BASE + 0x0080, AST_GPIO_BASE + 0x0118, AST_GPIO_BASE + 0x0130,
+     AST_GPIO_BASE + 0x0110, AST_GPIO_BASE + 0x00D0},
+    /* U/V/W/X */
+    {AST_GPIO_BASE + 0x0088, AST_GPIO_BASE + 0x0148, AST_GPIO_BASE + 0x0160,
+     AST_GPIO_BASE + 0x0140, AST_GPIO_BASE + 0x00D4},
+    /* Y/Z/AA/AB */
+    {AST_GPIO_BASE + 0x01E0, AST_GPIO_BASE + 0x0178, AST_GPIO_BASE + 0x0190,
+     AST_GPIO_BASE + 0x0170, AST_GPIO_BASE + 0x00D8},
+    /* AC */
+    {AST_GPIO_BASE + 0x01E8, AST_GPIO_BASE + 0x01A8, AST_GPIO_BASE + 0x01C0,
+     AST_GPIO_BASE + 0x01A0, AST_GPIO_BASE + 0x00DC},
+};
+
+#define AST_GPIO_PORT(gpio) (gpio >> 3)
+#define AST_GPIO_PIN(gpio) (gpio & 0x7)
+#define AST_GPIO_SHIFT(gpio)                                                   \
+    ((AST_GPIO_PORT(gpio) % 4) * 8 + AST_GPIO_PIN(gpio))
+
+/**
+ * @return Pointer to corresponding item from ast_gpio_regs table.
+ */
+#define AST_GPIO_REGS(gpio)                                                    \
+    ((AST_GPIO_PORT(gpio) / 4) < ARRAY_SIZE(ast_gpio_regs)                     \
+         ? (ast_gpio_regs + (AST_GPIO_PORT(gpio) / 4))                         \
+         : NULL)
+
+/**
+ * @brief Set a corresponding bit in specified register.
+ *
+ * @param val - Required bit value
+ * @param base - Register address
+ * @param shift - Bit index.
+ */
+#define AST_GPIO_WRITE(val, base, shift)                                       \
+    writel(((val) ? readl(base) | (1 << (shift))                               \
+                  : readl(base) & ~(1 << (shift))),                            \
+           base)
+
+/**
+ * @brief Get value of corresponging bit from specified register.
+ *
+ * @param base - Register address
+ * @param shift - Bit index
+ *
+ * @return Bit value
+ */
+#define AST_GPIO_READ(base, shift) ((readl(base) >> (shift)) & 1)
+
+int aspeed_gpio_get_value(unsigned gpio)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (!regs)
+    {
+        printf("%s: Invalid GPIO!\n", __func__);
+        return -1;
+    }
+    return AST_GPIO_READ(regs->base, AST_GPIO_SHIFT(gpio));
+}
+
+int aspeed_gpio_set_value(unsigned gpio, unsigned value)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (regs)
+    {
+        unsigned shift = AST_GPIO_SHIFT(gpio);
+        AST_GPIO_WRITE(value, regs->base, shift);
+    }
+    else
+    {
+        printf("%s: Invalid GPIO!\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+int aspeed_gpio_get_direction(unsigned gpio)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (!regs)
+    {
+        printf("%s: Invalid GPIO!\n", __func__);
+        return -1;
+    }
+    return AST_GPIO_READ(regs->base + 0x04, AST_GPIO_SHIFT(gpio));
+}
+
+int aspeed_gpio_set_direction(unsigned gpio, unsigned direction)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (regs)
+    {
+        unsigned shift = AST_GPIO_SHIFT(gpio);
+        AST_GPIO_WRITE(direction, regs->base + 0x04, shift);
+    }
+    else
+    {
+        printf("%s: Invalid GPIO!\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+int aspeed_gpio_enable_interrupt(unsigned gpio)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (regs)
+    {
+        unsigned shift = AST_GPIO_SHIFT(gpio);
+        AST_GPIO_WRITE(1, regs->intcfg, shift);
+    }
+    else
+    {
+        printf("%s: Invalid GPIO!\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+int aspeed_gpio_disable_interrupt(unsigned gpio)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (regs)
+    {
+        unsigned shift = AST_GPIO_SHIFT(gpio);
+        AST_GPIO_WRITE(0, regs->intcfg, shift);
+    }
+    else
+    {
+        printf("%s: Invalid GPIO!\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+int aspeed_gpio_set_trigger(unsigned gpio, unsigned trigger)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (regs)
+    {
+        unsigned shift = AST_GPIO_SHIFT(gpio);
+        AST_GPIO_WRITE(trigger & 0x1, regs->intcfg + 0x04, shift);
+        AST_GPIO_WRITE(trigger & 0x2, regs->intcfg + 0x08, shift);
+        AST_GPIO_WRITE(trigger & 0x4, regs->intcfg + 0x0C, shift);
+    }
+    else
+    {
+        printf("%s: Invalid GPIO!\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+int aspeed_gpio_clear_interrupt(unsigned gpio)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (regs)
+    {
+        unsigned shift = AST_GPIO_SHIFT(gpio);
+        AST_GPIO_WRITE(1, regs->intcfg + 0x10, shift);
+    }
+    else
+    {
+        printf("%s: Invalid GPIO!\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+int aspeed_gpio_set_debounce(unsigned gpio, unsigned debounce)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (regs)
+    {
+        unsigned shift = AST_GPIO_SHIFT(gpio);
+        AST_GPIO_WRITE(debounce & 0x1, regs->debounce + 0x00, shift);
+        AST_GPIO_WRITE(debounce & 0x2, regs->debounce + 0x04, shift);
+    }
+    else
+    {
+        printf("%s: Invalid GPIO!\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+/**
+ * @return A GPIO direction in human readable format.
+ */
+static const char* ast_gpio_direction(unsigned gpio)
+{
+    switch (aspeed_gpio_get_direction(gpio))
+    {
+        case ASPEED_GPIO_INPUT:
+            return "input";
+        case ASPEED_GPIO_OUTPUT:
+            return "output";
+        default:
+            break;
+    }
+    return "error";
+}
+
+/**
+ * @return An interrupt trigger settings in human readable format.
+ */
+static const char* ast_gpio_trigger(unsigned gpio)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (regs)
+    {
+        unsigned shift = AST_GPIO_SHIFT(gpio);
+        unsigned trigger = (AST_GPIO_READ(regs->intcfg + 0x04, shift) << 0) |
+                           (AST_GPIO_READ(regs->intcfg + 0x08, shift) << 1) |
+                           (AST_GPIO_READ(regs->intcfg + 0x0C, shift) << 2);
+        switch (trigger)
+        {
+            case ASPEED_GPIO_FALLING_EDGE:
+                return "fall";
+            case ASPEED_GPIO_RISING_EDGE:
+                return "rise";
+            case ASPEED_GPIO_LOW_LEVEL:
+                return "low ";
+            case ASPEED_GPIO_HIGH_LEVEL:
+                return "high";
+            default:
+                return "both";
+        }
+    }
+    return "error";
+}
+
+/**
+ * @return An interrupt status in human readable format.
+ */
+static const char* ast_gpio_int_status(unsigned gpio)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (regs)
+    {
+        unsigned shift = AST_GPIO_SHIFT(gpio);
+        if (AST_GPIO_READ(regs->intcfg, shift))
+        {
+            return AST_GPIO_READ(regs->intcfg + 0x10, shift) ? "pending"
+                                                             : "cleaned";
+        }
+        return "disabled";
+    }
+
+    return "error";
+}
+
+/**
+ * @return A debounce value in human readable format.
+ */
+static const char* ast_gpio_debounce(unsigned gpio)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (regs)
+    {
+        unsigned shift = AST_GPIO_SHIFT(gpio);
+        unsigned deb = (AST_GPIO_READ(regs->debounce + 0x00, shift) << 0) |
+                       (AST_GPIO_READ(regs->debounce + 0x04, shift) << 1);
+        switch (deb)
+        {
+            case ASPEED_GPIO_DEBOUNCE_NONE:
+                return "none";
+            case ASPEED_GPIO_DEBOUNCE_1:
+                return "timer1";
+            case ASPEED_GPIO_DEBOUNCE_2:
+                return "timer2";
+            case ASPEED_GPIO_DEBOUNCE_3:
+                return "timer3";
+            default:
+                break;
+        }
+    }
+
+    return "error";
+}
+
+/**
+ * @return A command source value in human readable format.
+ */
+static const char* ast_gpio_command_source(unsigned gpio)
+{
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (regs)
+    {
+        /* Used one bit per gpio port */
+        unsigned shift = AST_GPIO_SHIFT(gpio) - AST_GPIO_PIN(gpio);
+        unsigned cmdsrc = (AST_GPIO_READ(regs->cmdsrc + 0x00, shift) << 0) |
+                          (AST_GPIO_READ(regs->cmdsrc + 0x04, shift) << 1);
+
+        switch (cmdsrc)
+        {
+            /* The single place where these values are used is here. */
+            case 0x0:
+                return "ARM";
+            case 0x1:
+                return "LPC";
+            case 0x2:
+                return "CoCPU";
+            default:
+                return "Unknown";
+        }
+    }
+
+    return "error";
+}
+
+/**
+ * @brief Convert a string to GPIO line.
+ *
+ * @param str - GPIO name or line number
+ *
+ * @return - GPIO line or -1 if error.
+ */
+static int ast_gpio_parse(const char* str)
+{
+    int gpio = -1;
+
+    if (str)
+    {
+        if (isalpha(*str))
+        {
+            gpio = (toupper(*str) - 'A') << 3;
+
+            if (toupper(*str) == 'A' && toupper(*(str + 1)) >= 'A' &&
+                toupper(*(str + 1)) <= 'C')
+            {
+                str++;
+                gpio = (26 + toupper(*str) - 'A') << 3;
+            }
+
+            str++;
+            if (*str >= '0' && *str <= '7' && !*(str + 1))
+            {
+                gpio += *str - '0';
+            }
+            else
+            {
+                gpio = -1;
+            }
+        }
+        else if (isdigit(*str))
+        {
+            gpio = simple_strtoul(str, NULL, 0);
+        }
+    }
+
+    return gpio;
+}
+
+/**
+ * @brief Show status of specified GPIO.
+ *
+ * @param gpio - GPIO line
+ */
+static int ast_gpio_show_state(unsigned gpio)
+{
+    unsigned port = AST_GPIO_PORT(gpio);
+    unsigned pin = AST_GPIO_PIN(gpio);
+    unsigned shift = AST_GPIO_SHIFT(gpio);
+    ast_gpio_regs_t* regs = AST_GPIO_REGS(gpio);
+    if (!regs)
+    {
+        printf("%s: invalid GPIO!\n", __func__);
+        return -1;
+    }
+
+    printf("gpio %c%c%c line %3d: %s, int: %s, %s, deb: %s, src: %s, "
+           "val: %d/%d\n",
+           (port >= ASPEED_GPIO_PORT_AA ? 'A' : ' '),
+           ('A' + port % ASPEED_GPIO_PORT_AA), ('0' + pin), gpio,
+           ast_gpio_direction(gpio), ast_gpio_trigger(gpio),
+           ast_gpio_int_status(gpio), ast_gpio_debounce(gpio),
+           ast_gpio_command_source(gpio), aspeed_gpio_get_value(gpio),
+           AST_GPIO_READ(regs->data, shift));
+
+    return 0;
+}
+
+/**
+ * @brief `gpio` shell command hanler
+ *
+ * @param cmdtp -
+ * @param flag -
+ * @param argc - Number of arguments
+ * @param argv[] - List of arguments
+ *
+ * @return 0 if success, otherwise failed.
+ */
+static int do_gpio(cmd_tbl_t* cmdtp, int flag, int argc, char* const argv[])
+{
+    int gpio;
+
+    if (argc < 2)
+    {
+        printf("gpio: No GPIO specified!\n");
+        return 1;
+    }
+
+    gpio = ast_gpio_parse(argv[1]);
+    if (gpio < 0 || gpio > ASPEED_GPIO(AC, 7))
+    {
+        printf("gpio: Invalid GPIO!\n");
+        return 1;
+    }
+
+    if (argc == 4)
+    {
+        char first = tolower(argv[2][0]);
+        char second = first ? tolower(argv[2][1]) : '\0';
+        char c = tolower(argv[3][0]);
+
+        if (first == 'd' && second == 'i') /* direction */
+        {
+            /* input | output | 0 | 1 */
+            if (c == '0' || c == 'i')
+            {
+                aspeed_gpio_set_direction(gpio, ASPEED_GPIO_INPUT);
+            }
+            else if (c == '1' || c == 'o')
+            {
+                aspeed_gpio_set_direction(gpio, ASPEED_GPIO_OUTPUT);
+            }
+            else
+            {
+                printf("gpio: Invalid value!\n");
+                return 1;
+            }
+        }
+        else if (first == 'i') /* interrupt */
+        {
+            if (c == 'd' || c == '0')
+                /* disable | 0 */
+                aspeed_gpio_disable_interrupt(gpio);
+            else if (c == 'e' || c == '1')
+                /* enable | 1 */
+                aspeed_gpio_enable_interrupt(gpio);
+            else if (c == 'f')
+                /* falling-edge */
+                aspeed_gpio_set_trigger(gpio, ASPEED_GPIO_FALLING_EDGE);
+            else if (c == 'r')
+                /* rising-edge */
+                aspeed_gpio_set_trigger(gpio, ASPEED_GPIO_RISING_EDGE);
+            else if (c == 'l')
+                /* low-level */
+                aspeed_gpio_set_trigger(gpio, ASPEED_GPIO_LOW_LEVEL);
+            else if (c == 'h')
+                /* high-level */
+                aspeed_gpio_set_trigger(gpio, ASPEED_GPIO_HIGH_LEVEL);
+            else if (c == 'b')
+                /* both (dual-edge) */
+                aspeed_gpio_set_trigger(gpio, ASPEED_GPIO_DUAL_EDGE);
+            else if (c == 'c')
+                /* clear */
+                aspeed_gpio_clear_interrupt(gpio);
+            else
+            {
+                printf("gpio: Invalid interrupt setting!\n");
+                return 1;
+            }
+        }
+        else if (first == 'd' && second == 'e') /* debounce */
+        {
+            /* none | 0 | 1 | 2 | 3 */
+            if (c == 'n')
+                aspeed_gpio_set_debounce(gpio, ASPEED_GPIO_DEBOUNCE_NONE);
+            else if (c >= '0' && c <= '3')
+                aspeed_gpio_set_debounce(gpio,
+                                         ASPEED_GPIO_DEBOUNCE_NONE + c - '0');
+            else
+            {
+                printf("gpio: Invalid debounce setting!\n");
+                return 1;
+            }
+        }
+        else if (first == 'v') /* value */
+        {
+            /* high | low | 0 | 1 */
+            char c = tolower(argv[3][0]);
+            if (c == '0' || c == 'l')
+            {
+                aspeed_gpio_set_value(gpio, 0);
+            }
+            else if (c == '1' || c == 'h')
+            {
+                aspeed_gpio_set_value(gpio, 1);
+            }
+            else
+            {
+                printf("gpio: Invalid value!\n");
+                return 1;
+            }
+        }
+        else
+        {
+            printf("gpio: Unknown subcommand!\n");
+            return 1;
+        }
+    }
+    else if (argc == 2)
+    {
+        ast_gpio_show_state(gpio);
+    }
+    else
+    {
+        printf("gpio: all subcommands should have value!\n");
+        return 1;
+    }
+
+    return 0;
+}
+
+U_BOOT_CMD(
+    gpio, 4, 0, do_gpio, "do stuff with gpios",
+    "<line> [<direction|interrupt|debounce|value> <data>]\n"
+    "Without subcommands shows the current status of the specified gpio\n"
+    "  direction - change the the direction (0=input, 1=output)\n"
+    "  interrupt - change the interrupt settings\n"
+    "    enable/disable - enable or disable interrupt support\n"
+    "    clear - clear pending interrpupt flag\n"
+    "    fall/rise/low/high/both - change the interrupt trigger\n"
+    "  debounce - change the debounce settings (0-disable, 1,2,3 - timer)\n"
+    "  value - change the gpio value\n");
-- 
2.25.4

